/*
 * Copyright (C) 2018 Fionn Langhans
 */
package feder;

import java.util.*;

import feder.utils.NumberUtils;
import feder.utils.TextPositionManager;

/**
 * This class is responsible for the lexical analysis
 *
 * @author Fionn Langhans
 * @ingroup compiler
 */
public class Lexer {
	/**
	 * This are the strings of the tokens, which only differ if the token is a name
	 */
	public List<String> softokens;

	/**
	 * This are the tokens, which where generated by the lexical analysis
	 */
	public List<String> tokens;
	public List<Integer> postoken;
	public TextPositionManager tpm;
	public int errors = 0;
	public FederCompiler compiler;

	private int linestoadd = 0;

	public Lexer(FederCompiler compiler0) {
		compiler = compiler0;
	}

	public static final List<String> OPERATORS = Arrays.asList("==", "!=", "(", ")", ",", ".", "=", ";", "||", "&&",
	        "[]", "[", "]");

	/**
	 * Operators for Feder's rules
	 */
	public static final List<String> RULE_OPERATORS = Arrays.asList(
	            "<=>",
	            ">=", "<=", "<", ">", "+=", "-=", "*=", "/=", "%=",
	            "&=", "|=", "!",
	            "++", "--", "+", "-", "*", "/", "%", "^", "&", "|");

	/**
	 * Operators which have names
	 * (regular expr. (POSIX standard): [a-zA-Z_][a-zA-Z0-9_]*)
	 */
	public static final List<String> NAMED_OPERATOR = Arrays.asList("func", "class", "namespace", "if", "while", "for","else",
	        "continue", "break", "return", "true", "false", "null", "include", "import", "interface", "from", "global",
	        "type", "len", "append");

	/**
	 * Returns the numbers of tokens in the current line
	 * @return
	 */
	public int tokensinline() {
		int i;
		int result = 0;
		for (i = tokens.size() - 1; i >= 0 && !tokens.get(i).equals("newline"); i--) {
			result++;
		}

		return result;
	}

	/**
	 * Utility function for printing errors
	 * @param index index in the input text
	 * @param msg Error message
	 */
	public void error(int index, String msg) {
		for (int i = tokens.size() - 1; i >= 0 && !tokens.get(i).equals("newline"); i--) {
			tokens.remove(i);
		}

		tpm.error(index, msg);

		errors++;
	}

	/**
	 * Same as tpm.startsWith(s)
	 * @param s
	 * @return true if text at the current index starts with 's'
	 */
	public boolean startsWith(String s) {
		return tpm.startsWith(s);
	}

	/**
	 * This function increases tpm.indexChar, if an operator was found.
	 * @return Returns true, if the current token is an operator
	 */
	private boolean isOperator() {
		for (String operator : OPERATORS) {
			if (startsWith(operator)) {
				tokens.add(operator);
				softokens.add(operator);
				tpm.indexChar += operator.length();
				return true;
			}
		}

		return false;
	}

	/**
	 * This function increases tpm.indexChar, if an operator was found.
	 * @return Returns true, if the current token is an operator
	 */
	private boolean isRuleOperator() {
		for (String operator : RULE_OPERATORS) {
			if (startsWith(operator)) {
				tokens.add("roperator");
				softokens.add(operator);
				tpm.indexChar += operator.length();
				return true;
			}
		}

		return false;
	}

	/**
	 * This method performs a lexical analysis. The results of the method are
	 * saved in softokens and tokens. The method searches for strings, names,
	 * operators, keywords and other stuff.
	 *
	 * If an error occurred (something is not defined by the lexical rules), one
	 * will be added to @link Lexer.errors errors @endlink . The error will be
	 * printed to the console (standard output).
	 *
	 * @param text0 (hopefully) Feder source code
	 */
	public void lex(String text0) {
		tokens = new LinkedList<>();
		softokens = new LinkedList<>();
		postoken = new LinkedList<>();
		tpm = new TextPositionManager(0, 0, text0);
		tpm.filename = compiler.getName();
		errors = 0;

		int scope = 0;

		while (tpm.isPosValid()) {

			if (tpm.getNewLineOperatorLength(tpm.indexChar) > 0) {
				if (scope > 0) {
					linestoadd++;
					tpm.toNextLine();
					continue;
				}

				for (; linestoadd > 0; linestoadd--) {
					tokens.add("newline");
					softokens.add("\n");
				}

				// New Line
				softokens.add("\n");
				tokens.add("newline");
				tpm.toNextLine();
				continue;
			}

			if (isOperator()) {
				if (tokens.get(tokens.size()-1).equals("(")) {
					scope++;
				} else if (tokens.get(tokens.size()-1).equals(")")) {
					scope--;
				}

				continue;
			}

			if (isRuleOperator())
				continue;

			if ((tpm.startsWith("::") || tpm.startsWith(":")) && tokensinline() == 0) {
				boolean iscompilercommand = tpm.startsWith("::");
				if (iscompilercommand)
					tpm.indexChar += 2;
				else
					tpm.indexChar += 1;

				int index = tpm.findNextLine();
				String buildin = tpm.text.substring(tpm.indexChar, index);
				while (buildin.endsWith("\n") || buildin.endsWith("\r")) {
					buildin = buildin.substring(0, buildin.length() - 1);
				}

				if (iscompilercommand)
					tokens.add("command");
				else
					tokens.add("nativelang");

				softokens.add(buildin);

				tokens.add("newline");
				softokens.add("\n");

				tpm.toNextLine();
				continue;
			}

			if (tpm.startsWith("##")) {
				tpm.indexChar += 2;

				while (tpm.isPosValid() && !tpm.startsWith("##")) {
					int linessc = tpm.getNewLineOperatorLength(tpm.indexChar);
					if (linessc > 0) {
						linestoadd++;
						tpm.toNextLine();
						continue;
					}

					tpm.indexChar++;
				}

				if (tpm.isPosValid()) {
					tpm.indexChar += 2;
				} else {
					error(indexList, "Comment for multiple lines didn't end!");
				}

				continue;
			}

			// One liners (comments)
			if (tpm.startsWith("#")) {
				tpm.toNextLine();
                linestoadd++;

                if (scope == 0) {
    				for (; linestoadd > 0; linestoadd--) {
				    	tokens.add("newline");
				    	softokens.add("\n");
				    }
                }

				continue;
			}

			char c = tpm.text.charAt(tpm.indexChar);

			// Strings!
			if (c == '\"' || c == '\'') {
				tpm.indexChar++;
				char stringOpeningChar = c;

				int indexBeginning = tpm.indexChar;
				char cBeginning = c;
				boolean ignoreNextOne = false;

				final StringBuilder s = new StringBuilder();

				while (tpm.isPosValid() && ((c = tpm.text.charAt(tpm.indexChar)) != cBeginning || ignoreNextOne)) {
					if (c == '\\' && !ignoreNextOne) {
						ignoreNextOne = true;
					} else {
						ignoreNextOne = false;
					}

					int newline = tpm.getNewLineOperatorLength(tpm.indexChar);
					if (newline > 0) {
						tpm.line++;
						tpm.indexChar += newline;
						linestoadd++;
						continue;
					}

					s.append(c);
					tpm.indexChar++;
				}

				if (!tpm.isPosValid()) {
					error(indexBeginning, "");
					error(tpm.indexChar - 1, "String didn't terminate!");
					continue;
				}

				tpm.indexChar++;

				// Add string to tokens
				if (stringOpeningChar == '\'') {
					tokens.add("char");
				} else {
					tokens.add("string");
				}

				softokens.add(s.toString());

				continue;
			} // String

			final StringBuilder name = new StringBuilder();

			while (tpm.isPosValid() && !Character.isWhitespace(tpm.text.charAt(tpm.indexChar))
			        && (Character.isAlphabetic(tpm.text.charAt(tpm.indexChar))
			            || Character.isDigit(tpm.text.charAt(tpm.indexChar))
			            || tpm.text.charAt(tpm.indexChar) == '_')
			        || (name.length() > 0 && NumberUtils.isInteger(name.toString())
			            && tpm.text.charAt(tpm.indexChar) == '.')) {
				name.append(tpm.text.charAt(tpm.indexChar));
				tpm.indexChar++;
			}

			if (name.length() > 0) {
				if (NAMED_OPERATOR.contains(name.toString())) {
					// Its a named operator!
					softokens.add(name.toString());
					tokens.add(name.toString());
				} else if (NumberUtils.isInteger(name.toString()) || NumberUtils.isHexadecimalNumber(name.toString(), true)) {
					softokens.add(name.toString());
					tokens.add("int");
				} else if (NumberUtils.isFloat(name.toString())) {
					softokens.add(name.toString());
					tokens.add("double");
				} else if (Character.isDigit(name.charAt(0))) {
					error(tpm.indexChar - name.length(),
					      "\"" + name + "\": Names can't start with a digit, only numbers can.");
				} else {
					softokens.add(name.toString());
					tokens.add("name");
				}

				continue;
			}

			if (c != ' ' && c != '\t') {
				error(tpm.indexChar, "Character should be a space or turbolator!");
				continue;
			}

			// Is a space, skip character
			tpm.indexChar++;
		}

		if (errors > 0)
			return;
	}

	public int indexList;

	/**
	 * Returns the token at 'index'
	 * @param index
	 * @return
	 *
	 * @error Possible error, if index is out of the bounds of tokens
	 */
	public String getToken(int index) {
		if (index >= tokens.size()) {
			throw new RuntimeException("Expected a token, but none is available!");
		}

		return tokens.get(index);
	}

	/**
	 * @return Returns the token at the current index (indexList)
	 */
	public String getToken() {
		return getToken(indexList);
	}

	/**
	 * @param index
	 * @param allowed_tokens
	 * @return Returns the token at index
	 *
	 * @error If the current token is not in allowed_tokens an error
	 * is thrown
	 */
	public String getTokenWhitelist(int index, String... allowed_tokens) {
		String token = getToken(index);
		StringBuilder summary = new StringBuilder();
		for (String allowed_token : allowed_tokens) {
			if (allowed_token.equals(token)) {
				return token;
			}

			if (!allowed_token.equals(allowed_tokens[0])) {
				summary.append(", ");
			}

			summary.append(allowed_token);
		}

		throw new RuntimeException("Expected specific tokens:\"" + summary.toString() + "\", but none of them came!");
	}

	/**
	 * @param allowed_tokens
	 * @return Returns the token at the current index
	 *
	 * @error If the current token is not in allowed_tokens an error
	 * is thrown
	 */
	public String getTokenWhitelist(String... allowed_tokens) {
		return getTokenWhitelist(indexList, allowed_tokens);
	}

	/**
	 * @param index an index in the bounds of softokens
	 * @return Returns softokens.get(index)
	 */
	public String getStringOfToken(int index) {
		if (index >= softokens.size()) {
			throw new RuntimeException("Expected a token, but none is available!");
		}

		return softokens.get(index);
	}

	/**
	 * @return Returns the current value of the current token
	 */
	public String getStringOfToken() {
		return getStringOfToken(indexList);
	}

	/**
	 * Debug output
	 */
	public void dbgOutput() {
		for (String token : tokens) {
			if (token.equals("newline")) {
				System.out.print(token + " ");
			} else {
				System.out.print(token + " ");
			}
		}

		System.out.println();
	}
}
