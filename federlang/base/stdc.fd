##
# stdc.fd
# created by Fionn Langhans <fionn.langhans@gmail.com> 
#
# This file ist part of the Feder standard library and
# contains C code (in Feder) which is required by the Feder compiler.
##

namespace h_intern
::if POSIX
	# Sometimes POSIX headers (or POSIX operations included
	# in C standard headers) are necessary (if available)
	:#define _POSIX_C_SOURCE 200809L
::fi

	# Include some C files
	:#include <stdlib.h>
	:#include <string.h>
	:#include <stdint.h>
	:#include <stdbool.h>

	# Flags for the garbage collection
	:#define FD_GC_FLAG_NONE 0x00
	:#define FD_GC_FLAG_MARKED 0x01

	# Time the garbage collection waits till another garbage collect
	# 30 seconds
	:#define FD_GC_WAIT 30

	# Mainly used for NullPointer (Exceptions) in this case
	:#include <stdio.h>

	# Forward declaration of objects
	:struct _fdobject;
	:typedef struct _fdobject fdobject;

	# Forward declaration of roots
	:struct _fdroot;
	:typedef struct _fdroot fdroot;

	# For the garbage collection
	:extern fdroot** fd_gc_roots;
	:extern fdobject** fd_gc_objects;

	:extern size_t fd_gc_roots_length;
	:extern size_t fd_gc_objects_length;

	##
	# Feder's classes need this typedef to be able
	# to declare and define an interface, which deletes
	# objects of that class.
	##
	:typedef void (* PFDDELETE) (void * data);

	##
	# This function returns all elements of an object
	##
	:typedef fdobject* (* PFDGETELEMENT) (fdobject* obj, int index);

	:struct _fdroot {
		:fdobject ** objects;
		:int length;
	:};

	##
	# Initializes the garbage collection
	##
	:void
	:fdInitGarbageCollection ();

	##
	# Terminates the garbage collection
	##
	:void
	:fdTerminateGarbageCollection ();

	##
	# Collects garbage if necessary
	##
	:void
	:fdCollectGarbage ();

	##
	# Collect garbage, but forced
	##
	:void
	:fdForceCollectGarbage ();

	##
	# Creats a root
	##
	:fdroot*
	:fdCreateRoot ();

	##
	# Deletes a root
	##
	:void
	:fdDeleteRoot (fdroot* root);

	:void
	:fdAddObject (fdobject* obj);

	:void
	:fdAddObjectToRoot (fdroot* root, fdobject * obj);

	##
	# Every class, which was previously created in Feder
	# must be casted to the typedef fdobject.
	##
	:struct _fdobject {
		# The function to delete an object of a class
		:PFDDELETE delfn;

		:PFDGETELEMENT getelement;
		:int length;

		:char flag;
	:};

	# This function calls the delete function
	# of the given object
	:void
	:fdDeleteObject (fdobject * object);

	##
	# This function gets called if a function
	# returns something and was called. It deletes
	# an object if the object's reference counter
	# is equal to zero.
	##
	:void
	:fdRemoveObject_func (fdobject * object);
	
	##
	# This function gets called, if a new objects
	# gets assigned to another
	##
	:fdobject *
	:fdAssignObject (fdroot* root, fdobject * object);

	##
	# This function gets called, if a old objects
	# has been assigned to another. It calls
	# the remove function of the old object.
	# And this function also assigns the old
	# object to the new one
	##
	:fdobject *
	:fdAssignObjectOld (fdroot* root,
	                   :fdobject ** oldobj,
	                   :fdobject * newobj);

	# Type arrays

	:struct _fdtypearray;
	:typedef struct _fdtypearray fdtypearray ;

	:struct _fdtypearray {
		# The function to delete an object of a class
		:PFDDELETE delfn;

		:PFDGETELEMENT getelement;
		:int length;

		# Flag for the garbage collection algo
		:char flag;

		:char * data;
		:int typesize;
	:};

	:fdobject*
	:fdtypearray_getelement (fdobject* obj, int index);

	# Functions for arrays
	:fdtypearray*
	:fdCreateTypeArray (int typesize, int size);

	:void
	:fdDeleteTypeArray (void * data);

	:int
	:fdGetTypeArrayLength (fdtypearray* ar);

	:fdtypearray*
	:fdAppendToTypeArray (fdtypearray* ar, char * data);


	# Class arrays

	:struct _fdclassarray;
	:typedef struct _fdclassarray fdclassarray;

	:struct _fdclassarray {
		:PFDDELETE delfn;

		:PFDGETELEMENT getelement;
		:int length;

		# Flag for the garbage collection algo
		:char flag;

		:fdobject* * data;
	:};

	:fdobject*
	:fdclassarray_getelement (fdobject* obj, int index);

	:fdclassarray*
	:fdCreateClassArray (int size);

	:void
	:fdDeleteClassArray (void * data);

	:int
	:fdGetClassArrayLength (fdclassarray * ar);

	:fdclassarray*
	:fdAppendToClassArray (fdclassarray* ar, fdobject * obj);

	:fdobject*
	:fdGetClassArrayObjectAt (fdclassarray* ar, int index);

	:bool
	:fdExistsObjectInClassArray (fdobject * obj0, fdobject * existsObj);
;

# Define all declared functions
namespace c_intern
	:#include <stdio.h>

	:fdroot** fd_gc_roots;
	:fdobject** fd_gc_objects;

	:size_t fd_gc_roots_length;
	:size_t fd_gc_objects_length;

	:void
	:fdInitGarbageCollection ()  {
		:fd_gc_roots_length = 50;
		:fd_gc_objects_length = 200;
		:fd_gc_roots = (fdroot*) calloc (fd_gc_roots_length, sizeof (fdroot*));
		:fd_gc_objects = (fdobject*) calloc (fd_gc_objects_length,
		                                    :sizeof (fdobject*));
	:}

	:void
	:fdTerminateGarbageCollection () {
		# First thought: Lets collect garbage
		# Second: Idiot all objects are garbage
		# => kill it all
		:for (size_t i = 0; i < fd_gc_roots_length; i++) {
			:fdDeleteRoot (fd_gc_roots[i]);
		:}

		:for (size_t i = 0; i < fd_gc_objects_length; i++) {
			:fdDeleteObject (fd_gc_objects[i]);
		:}
	:}

	:void
	:fdMarkObject (fdobject* obj) {
		:if (!obj) return;

		:obj->flag |= FD_GC_FLAG_MARKED;
		:for (int i = 0; i < obj->length; i++) {
			:fdMarkObject (obj->getelement (i));
		:}
	:}

	:void
	:fdCollectGarbage () {
		:fdForceCollectGarbage ();
	:}

	:void
	:fdForceCollectGarbage () {
		:for (size_t i = 0; i < fd_gc_roots_length; i++) {
			:fdroot* root = fd_gc_roots_length[i];
			:for (size_t n = 0; n < root->length; n++) {
				:fdMarkObject (root->objects[n]);
			:}
		:}

		:for (size_t i = 0; i < fd_gc_objects_length; i++) {
			:if (fd_gc_objects && !fd_gc_objects[i]->flag) {
				# The object is garbage
				:fdDeleteObject (fd_gc_objects[i]);
				:fd_gc_objects[i] = NULL;
			:}
		:}
	:}

	:fdroot*
	:fdCreateRoot () {
		:fdroot* result = malloc (sizeof (fdroot*));
		:result->length = 10;
		:result->objects = (fdobject**) calloc (result->length,
		                                       :sizeof (fdobject*));
		
		:for (size_t i = 0; i < fd_gc_roots_length; i++) {
			:if (!fd_gc_roots[i]) {
				:fd_gc_roots[i] = result;
				:return result;
			:}
		:}

		:fd_gc_roots = (fdroot**) realloc (fd_gc_roots,
		                                  :(fd_gc_roots_length+5)
										    :* sizeof (fdroot*));
		:fd_gc_roots_length += 5;

		:return result;
	:}

	:void
	:fdDeleteRoot (fdroot* root) {
		:if (!root) return;

		:for (size_t i = 0; i < fd_gc_roots_length; i++) {
			:if (fd_gc_roots[i] == root) {
				:fd_gc_roots[i] = NULL;
				:break;
			:}
		:}

		:free (root->objects);
		:free (root);
	:}

	:void
	:fdAddObject (fdobject* obj);

	:void
	:fdAddObjectToRoot (fdroot* root, fdobject * obj);


	:void
	:fdDeleteObject (fdobject * object) {
		:if (!object) return;

		:object->delfn (object);
:#ifdef DEBUG
		:puts ("Deleted object");
:#endif
	:}

	:void
	:fdRemoveObject_func (fdobject * object) {
		:if (!object)
		:return;

		:if (object->usage <= 0)
		:fdDeleteObject (object);
	:}

	:fdobject *
	:fdAssignObject (fdroot* root, fdobject * object) {
		:if (!object) return NULL;

		
		:return object;
	:}

	:fdobject *
	:fdAssignObjectOld (fdroot* root, fdobject ** objold,
	                   :fdobject * objnew) {

		:fdRemoveObject (*objold);
		:*objold = objnew;
		:return *objold;
	:}

	:void
	:fdDecreaseUsage (fdobject * object) {
		:if (!object) return;
		:object->usagefn (object, 0);
	:}

	:bool
	:fdExistsObjectIn (fdobject * obj0, fdobject * objToSearch) {
		:if (!obj0) return false;
		:if (obj0 == objToSearch) return true;

		:if (!obj0->existsPointer)
			:return false;

		:return obj0->existsPointer (obj0, objToSearch);
	:}

	# Type array

	:fdobject*
	:fdtypearray_getelement (fdobject* obj, int index) {
		:return NULL; // NOTHING  to return
	:}

	:void
	:fdIncreaseUsageTypeArray (fdobject* obj, int usage) {
		:if (!obj) return;
		:if (usage) {
			:obj->usage++;
		:} else {
			:obj->usage--;
		:}
	:}

	:void
	:fdDeleteTypeArray (void* data) {
		:if (!data) return;
		:fdtypearray* ar = (fdtypearray*) data;
		:free (ar->data);
		:free (ar);
	:}

	:fdtypearray*
	:fdCreateTypeArray (int typesize, int size) {
		:fdtypearray* result = (fdtypearray*) malloc (sizeof (fdtypearray));
		:result->delfn = fdDeleteTypeArray;
		:result->getelement = fdtypearray_getelement;

		:result->data = (char*) malloc (size * typesize);
		:result->length = size;
		:result->typesize = typesize;

		:return result;
	:}

	:int
	:fdGetTypeArrayLength (fdtypearray* ar) {
		:if (!ar)
			:return 0;
		:int result = ar->length;
		:fdRemoveObject_func ((fdobject*) ar);
		:return result;
	:}

	:fdtypearray*
	:fdAppendToTypeArray (fdtypearray* ar, char * data) {
		:ar->length += 1;
		:ar->data = (char*) realloc ((void*) ar->data, ar->length * ar->typesize);
		:memcpy (ar->data + ((ar->length-1) * ar->typesize), data, ar->typesize);
		:ar->existsPointer = NULL;
		:return ar;
	:}

	# Class array

	:fdobject*
	:fdclassarray_getelement (fdobject* obj, int index) {
		:fdclassarray* ar = (fdclassarray*) obj;
		:return ar->data[index];
	:}

	:fdclassarray*
	:fdCreateClassArray (int size) {
		:fdclassarray* result = (fdclassarray*) malloc (sizeof (fdclassarray));
		:result->usage = 0;
		:result->delfn = fdDeleteClassArray;
		:result->length = size;
		:result->getelement = fdclassarray_getelement;
		
		# Create the data
		:result->data = (fdobject**) malloc (size * sizeof (fdobject*));
		# Assign the created data to NULL
		:for (int i = 0; i < size; i++) {
			:result->data[i] = NULL;
		:}

		:return result;
	:}

	:void
	:fdDeleteClassArray (void * data) {
		:if (!data)
			:return;

		:fdclassarray* todel = (fdclassarray*) data;
		:for (int i = 0; i < todel->length; i++) {
			:fdRemoveObject (todel->data[i]);
		:}

		:free (todel->data);
		:free (todel);
	:}

	:void
	:fdIncreaseUsageClassArray (fdobject * obj, int increase) {
		:if (!obj) return;
		:if (increase) {
			:obj->usage++;
		:} else {
			:obj->usage--;
		:}
	:}

	:int
	:fdGetClassArrayLength (fdclassarray * ar) {
		:if (!ar)
			:return 0;

		:int length = ar->length;
		:fdRemoveObject_func ((fdobject*) ar);
		:return length;
	:}

	:fdclassarray*
	:fdAppendToClassArray (fdclassarray* ar, fdobject * obj) {
		:if (!ar)
			:return NULL;

		:ar->length += 1;
		:ar->data = (fdobject**) realloc ((void*) ar->data, ar->length * sizeof (fdobject*));
		:if (!obj)
		  :ar->data[ar->length - 1] = NULL;
		:else
		  :ar->data[ar->length - 1] = fdAssignObject (obj);
		
		:return ar;
	:}

	:fdobject*
	:fdGetClassArrayObjectAt (fdclassarray* ar, int index) {
		:if (!ar)
			:return NULL;

		# Out of bounds
		:if (index < 0 || index >= ar->length)
			:return NULL;
		
		:fdobject* result = ar->data[index];
		# Necessary, if ar gets deleted from heap
		:fdIncreaseUsage (result);
		:fdRemoveObject_func ((fdobject*) ar);
		:fdDecreaseUsage (result);

		:return result;
	:}

	:bool
	:fdExistsObjectInClassArray (fdobject * obj0, fdobject* existsObj) {
		:fdclassarray * ar = (fdclassarray*) obj0;
		:for (int i = 0; i < ar->length; i++) {
			:if (ar->data[i] == existsObj) {
				:return true;
			:}
		:}

		:return false;
	:}
;

# {0} = is the identifier (like a line number)
# or the amount of how many roots are above this one
::rule struct create_root "fdroot* root{0} = fdCreateRoot ();"
::rule struct delete_root "fdDeleteRoot (root{0});"

::rule struct collect_garbage "fdCollectGarbage ();"
::rule struct init_gc "fdInitGarbageCollection ();"
::rule struct term_gc "fdTerminateGarbageCollection ();"

::rule struct remove_func "fdRemoveObject_func ((fdobject*) {0})"
::rule struct assign_obj "fdAssignObject ((fdobject*) {0})"
::rule struct assign_obj_old "fdAssignObjectOld ((fdobject**) &{0}, (fdobject*) {1})"

::rule struct this_is_null "if (!{0}) puts (\"This is null in file {1} in line {2}\") ;"

::rule struct basic_object_header "PFDGETELEMENT getelement; int length; char flag;"

class object
;

# Now the precedences of the standard operators are set
# Arithmetic
::rule precedence + 50
::rule precedence - 50
::rule precedence * 60
::rule precedence / 60
# binary
::rule precedence % 30
::rule precedence | 30
# boolean
::rule precedence ! 20
# boolean comparison
::rule precedence != 20
::rule precedence == 20
::rule precedence >= 20
::rule precedence <= 20
::rule precedence >  20
::rule precedence <  20
# boolean combinations
::rule precedence && 10
::rule precedence || 10
