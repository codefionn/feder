##
# stdc.fd
# created by Fionn Langhans <fionn.langhans@gmail.com> 
#
# This file ist part of the Feder standard library and
# contains C code (in Feder) which is required by the Feder compiler.
##

namespace h_intern
	::if POSIX
	# Sometimes POSIX headers (or POSIX operations included
	# in C standard headers) are necessary (if available)
	:#define _POSIX_C_SOURCE 200809L
	::fi

	# Include some C files
	:#include <stdlib.h>
	:#include <string.h>
	:#include <stdint.h>
	:#include <stdbool.h>

	# Flags for garbage collectable objects
	:#define FD_GC_OBJECT_FLAG_NONE 0x01
	:#define FD_GC_OBJECT_FLAG_BLACK 0x02
	:#define FD_GC_OBJECT_FLAG_GREY 0x04
	:#define FD_GC_OBJECT_FLAG_WHITE 0x08

	# Mainly used for NullPointer (Exceptions) in this case
	:#include <stdio.h>

	# Forward declaration
	:struct _fdobject;
	:typedef struct _fdobject fdobject;

	##
	# Feder's classes need this typedef to be able
	# to declare and define an interface, which deletes
	# objects of that class.
	##
	:typedef void (* PFDDELETE) (void * data);

	##
	# Feder's classes need this typedef (interface) to be
	# able to declare and define interface, which checks if
	# a certain pointer is in the object.
	##
	:typedef bool (* PFDEXISTS) (fdobject * obj, fdobject * pointerToCheck);

	##
	# Because every class in Feder needs a function,
	# which decreases an object's usage (and the objects'
	# objects usage), this typedef has to be defined
	##
	:typedef void (* PFDUSAGE) (fdobject * obj, int increase);

	##
	# Every class, which was previously created in Feder
	# must be casted to the typedef fdobject.
	##
	:struct _fdobject {
	
		# reference counter
		# (drops or is zero => object will be deleted)
		# [deprecated]
		:int usage;

		# The function to delete an object of a class
		:PFDDELETE delfn;

		# The function to increase/decrease the object's
		# reference counter
		:PFDUSAGE usagefn;

		# The function detects objects (pointers) in this object
		:PFDEXISTS existsPointer;

		:char flag;
	:};

	# Three sets for the tri-color marking garbage collection
	:extern fdobject ** gc_stack_black;
	:extern fdobject ** gc_stack_grey;
	:extern fdobject ** gc_stack_white;

	# The length of the stacks
	:extern size_t gc_stack_black_len;
	:extern size_t gc_stack_grey_len;
	:extern size_t gc_stack_white_len;

	##
	# This function initializes garbage collection.
	# All lengths get assign to best practice values and
	# the corresponding stack will be created.
	##
	:void
	:fdInitGarbageCollection();

	##
	# This function collects all garbage produced by the
	# system. It searches through all grey objects, and 
	# and checks references to white objects. If a reference
	# was found that object will be put into the grey stack.
	##
	:void
	:fdCollectGarbage();

	##
	# Adds the object 'obj' to the black stack of the
	# garbage collector. These objects are definitly used
	# and don't have any references to 'white' objects.
	##
	:fdobject*
	:fdAddObjectAsBlack (fdobject * obj);
	
	##
	# Adds the object 'obj' to the grey stack of the
	# garbage collector. These objects are used by black
	# objects, so they won't be garbage collected. After
	# calling the fdCollectGarbage function, this object
	# will be put into the black stack.
	##
	:fdobject*
	:fdAddObjectAsGrey (fdobject * obj);

	##
	# Adds the object 'obj' to the white stack of the
	# garbage collector. These objects might be used
	# be referenced by 'grey' objects. If they are, they
	# are put into the 'black' object stack.
	##
	:fdobject*
	:fdAddObjectAsWhite (fdobject * obj);

	# This function calls the delete function
	# of the given object
	:void
	:fdDeleteObject (fdobject * object);

	##
	# This function decreases the object's reference
	# counter. If the counter drops to zero or is
	# already zero, the delete function of the object
	# gets called.
	##
	:void
	:fdRemoveObject (fdobject * object);
	
	##
	# This function gets called if a function
	# returns something and was called. It deletes
	# an object if the object's reference counter
	# is equal to zero.
	##
	:void
	:fdRemoveObject_func (fdobject * object);
	
	##
	# This function gets called, if a new objects
	# gets assigned to another
	##
	:fdobject *
	:fdAssignObject (fdobject * object);

	##
	# This function gets called, if a old objects
	# has been assigned to another. It calls
	# the remove function of the old object.
	# And this function also assigns the old
	# object to the new one
	##
	:fdobject *
	:fdAssignObjectOld (fdobject ** oldobj,
	:				   fdobject * newobj);

	##
	# This function gets called, if an object's
	# reference counter should be increased.
	##
	:void
	:fdIncreaseUsage (fdobject * object);

	##
	# This function gets called, if an object's
	# reference counter should be decreased.
	##
	:void
	:fdDecreaseUsage (fdobject * object);

	##
	# Checks if 'objToSearch' exists in 'obj0'.
	##
	:bool
	:fdExistsObjectIn (fdobject * obj0, fdobject * objToSearch);

	# Type arrays

	:struct _fdtypearray;
	:typedef struct _fdtypearray fdtypearray ;

	:struct _fdtypearray {
		# reference counter
		# (drops or is zero => object will be deleted)
		:int usage;
		# The function to delete an object of a class
		:PFDDELETE delfn;
		# The function to increase/decrease the object's
		# reference counter
		:PFDUSAGE usagefn;
		:PFDEXISTS existsPointer;
		# Flag for the garbage collection algo
		:char flag;

		:char * data;
		:int length;
		:int typesize;
	:};

	# Functions for arrays
	:fdtypearray*
	:fdCreateTypeArray (int typesize, int size);

	:void
	:fdDeleteTypeArray (void * data);

	:void
	:fdIncreaseUsageTypeArray (fdobject * obj, int increase);

	:int
	:fdGetTypeArrayLength (fdtypearray* ar);

	:fdtypearray*
	:fdAppendToTypeArray (fdtypearray* ar, char * data);


	# Class arrays

	:struct _fdclassarray;
	:typedef struct _fdclassarray fdclassarray;

	:struct _fdclassarray {
		:int usage;
		:PFDDELETE delfn;
		:PFDUSAGE usagefn;
		:PFDEXISTS existsPointer;
		# Flag for the garbage collection algo
		:char flag;

		:fdobject ** data;
		:int length;
	:};

	:fdclassarray*
	:fdCreateClassArray (int size);

	:void
	:fdDeleteClassArray (void * data);

	:void
	:fdIncreaseUsageClassArray (fdobject * obj, int increase);

	:int
	:fdGetClassArrayLength (fdclassarray * ar);

	:fdclassarray*
	:fdAppendToClassArray (fdclassarray* ar, fdobject * obj);

	:fdobject*
	:fdGetClassArrayObjectAt (fdclassarray* ar, int index);

	:bool
	:fdExistsObjectInClassArray (fdobject * obj0, fdobject * existsObj);
;

# Define all declared functions
namespace c_intern
	:#include <stdio.h>

	# Three sets for the tri-color marking garbage collection
	:fdobject ** gc_stack_black = NULL;
	:fdobject ** gc_stack_grey = NULL;
	:fdobject ** gc_stack_white = NULL;

	:size_t gc_stack_black_len;
	:size_t gc_stack_grey_len;
	:size_t gc_stack_white_len;

	:void
	:fdInitGarbageCollection () {
		:gc_stack_black_len = 50;
		:gc_stack_grey_len = 1000;
		:gc_stack_white_len = 30;

		:gc_stack_black = (fdobject**) calloc (sizeof (fdobject*), gc_stack_black_len);
		:gc_stack_grey = (fdobject**) calloc (sizeof (fdobject*), gc_stack_grey_len);
		:gc_stack_white = (fdobject**) calloc (sizeof (fdobject*), gc_stack_white_len);
	:}

	:static fdobject*
	:fdObjectAddTo (fdobject *** gc_stack, size_t * gc_stack_len, fdobject * obj) {
		:for (int i = 0; i < *gc_stack_len; i++) {
			:(*gc_stack)[i] = obj;
			:return obj;
		:}

		# The object could be assigned to a missing place in
		# the garbage collector. We have to reallocate some space
		# assign the newly created fields to 'null' and assign
		# 'obj' to the first available value 'gc_stack_len'.

		:int old_gc_stack_len = *gc_stack_len;
		:*gc_stack_len += 50; // Reserve 50 new objects
		:*gc_stack = (fdobject**) realloc ((void*) (*gc_stack), *gc_stack_len * sizeof (fdobject*));

		:for (int i = 0; i < 50; i++) {
			:(*gc_stack)[old_gc_stack_len + i] = NULL;
		:}

		:(*gc_stack)[old_gc_stack_len] = obj;
		
		:return obj;
	:}

	:fdobject*
	:fdAddObjectAsBlack (fdobject * obj) {
		:return fdObjectAddTo (&gc_stack_black, &gc_stack_black_len, obj);
	:}
	
	:fdobject*
	:fdAddObjectAsGrey (fdobject * obj) {
		:return fdObjectAddTo (&gc_stack_grey, &gc_stack_grey_len, obj);
	:}

	:fdobject*
	:fdAddObjectAsWhite (fdobject * obj) {
		:return fdObjectAddTo (&gc_stack_white, &gc_stack_white_len, obj);
	:}

	:void
	:fdDeleteObject (fdobject * object) {
	:  if (!object) return;
	:
	:  object->usage = 100;
	:  object->delfn (object);
	:  #ifdef DEBUG
	:  puts ("Deleted object");
	:  #endif
	:}

	:void
	:fdRemoveObject (fdobject * object) {
	:  if (!object) return;
	:
	:  if (object->usage > 1) {
	:	fdDecreaseUsage (object);
	:	return;
	:  }
	:
	:  fdDeleteObject (object);
	:}

	:void
	:fdRemoveObject_func (fdobject * object) {
	:  if (!object)
	:	return;
	:
	:  if (object->usage <= 0)
	:	fdDeleteObject (object);
	:}

	:fdobject *
	:fdAssignObject (fdobject * object) {
	:  if (!object)
	:	return NULL;
	:
	:  fdIncreaseUsage (object);
	:  return object;
	:}

	:fdobject *
	:fdAssignObjectOld (fdobject ** objold,
	:				   fdobject * objnew) {
	:
	:  fdIncreaseUsage (objnew);
	:  fdRemoveObject (*objold);
	:  *objold = objnew;
	:  return *objold;
	:}

	:void
	:fdIncreaseUsage (fdobject * object) {
	:  if (!object) return;
	:  object->usagefn (object, 1);
	:}

	:void
	:fdDecreaseUsage (fdobject * object) {
	:  if (!object) return;
	:  object->usagefn (object, 0);
	:}

	:bool
	:fdExistsObjectIn (fdobject * obj0, fdobject * objToSearch) {
		:if (!obj0) return false;
		:if (obj0 == objToSearch) return true;

		:if (!obj0->existsPointer)
			:return false;

		:return obj0->existsPointer (obj0, objToSearch);
	:}

	# Type array

	:void
	:fdIncreaseUsageTypeArray (fdobject* obj, int usage) {
		:if (!obj) return;
		:if (usage) {
			:obj->usage++;
		:} else {
			:obj->usage--;
		:}
	:}

	:void
	:fdDeleteTypeArray (void* data) {
		:if (!data) return;
		:fdtypearray* ar = (fdtypearray*) data;
		:free (ar->data);
		:free (ar);
	:}

	:fdtypearray*
	:fdCreateTypeArray (int typesize, int size) {
		:fdtypearray* result = (fdtypearray*) malloc (sizeof (fdtypearray));
		:result->usage = 0;
		:result->delfn = fdDeleteTypeArray;
		:result->usagefn = fdIncreaseUsageTypeArray;

		:result->data = (char*) malloc (size * typesize);
		:result->length = size;
		:result->typesize = typesize;

		:return result;
	:}

	:int
	:fdGetTypeArrayLength (fdtypearray* ar) {
		:if (!ar)
			:return 0;
		:int result = ar->length;
		:fdRemoveObject_func ((fdobject*) ar);
		:return result;
	:}

	:fdtypearray*
	:fdAppendToTypeArray (fdtypearray* ar, char * data) {
		:ar->length += 1;
		:ar->data = (char*) realloc ((void*) ar->data, ar->length * ar->typesize);
		:memcpy (ar->data + ((ar->length-1) * ar->typesize), data, ar->typesize);
		:ar->existsPointer = NULL;
		:return ar;
	:}

	# Class array

	:fdclassarray*
	:fdCreateClassArray (int size) {
		:fdclassarray* result = (fdclassarray*) malloc (sizeof (fdclassarray));
		:result->usage = 0;
		:result->delfn = fdDeleteClassArray;
		:result->usagefn = fdIncreaseUsageClassArray;
		:result->length = size;
		:result->existsPointer = fdExistsObjectInClassArray;
		
		# Create the data
		:result->data = (fdobject**) malloc (size * sizeof (fdobject*));
		# Assign the created data to NULL
		:for (int i = 0; i < size; i++) {
			:result->data[i] = NULL;
		:}

		:return result;
	:}

	:void
	:fdDeleteClassArray (void * data) {
		:if (!data)
			:return;

		:fdclassarray* todel = (fdclassarray*) data;
		:for (int i = 0; i < todel->length; i++) {
			:fdRemoveObject (todel->data[i]);
		:}

		:free (todel->data);
		:free (todel);
	:}

	:void
	:fdIncreaseUsageClassArray (fdobject * obj, int increase) {
		:if (!obj) return;
		:if (increase) {
			:obj->usage++;
		:} else {
			:obj->usage--;
		:}
	:}

	:int
	:fdGetClassArrayLength (fdclassarray * ar) {
		:if (!ar)
			:return 0;

		:int length = ar->length;
		:fdRemoveObject_func ((fdobject*) ar);
		:return length;
	:}

	:fdclassarray*
	:fdAppendToClassArray (fdclassarray* ar, fdobject * obj) {
		:if (!ar)
			:return NULL;

		:ar->length += 1;
		:ar->data = (fdobject**) realloc ((void*) ar->data, ar->length * sizeof (fdobject*));
		:if (!obj)
		  :ar->data[ar->length - 1] = NULL;
		:else
		  :ar->data[ar->length - 1] = fdAssignObject (obj);
		
		:return ar;
	:}

	:fdobject*
	:fdGetClassArrayObjectAt (fdclassarray* ar, int index) {
		:if (!ar)
			:return NULL;

		# Out of bounds
		:if (index < 0 || index >= ar->length)
			:return NULL;
		
		:fdobject* result = ar->data[index];
		# Necessary, if ar gets deleted from heap
		:fdIncreaseUsage (result);
		:fdRemoveObject_func ((fdobject*) ar);
		:fdDecreaseUsage (result);

		:return result;
	:}

	:bool
	:fdExistsObjectInClassArray (fdobject * obj0, fdobject* existsObj) {
		:fdclassarray * ar = (fdclassarray*) obj0;
		:for (int i = 0; i < ar->length; i++) {
			:if (ar->data[i] == existsObj) {
				:return true;
			:}
		:}

		:return false;
	:}
;

::rule struct increase "fdIncreaseUsage ((fdobject*) {0})"
::rule struct decrease "fdDecreaseUsage ((fdobject*) {0})"
::rule struct remove "fdRemoveObject ((fdobject*) {0})"
::rule struct remove_func "fdRemoveObject_func ((fdobject*) {0})"
::rule struct assign_obj "fdAssignObject ((fdobject*) {0})"
::rule struct assign_obj_old "fdAssignObjectOld ((fdobject**) &{0}, (fdobject*) {1})"

::rule struct this_is_null "if (!{0}) puts (\"This is null in file {1} in line {2}\") ;"

class object
;

# Now the precedences of the standard operators are set
# Arithmetic
::rule precedence + 50
::rule precedence - 50
::rule precedence * 60
::rule precedence / 60
# binary
::rule precedence % 30
::rule precedence | 30
# boolean
::rule precedence ! 20
# boolean comparison
::rule precedence != 20
::rule precedence == 20
::rule precedence >= 20
::rule precedence <= 20
::rule precedence >  20
::rule precedence <  20
# boolean combinations
::rule precedence && 10
::rule precedence || 10
